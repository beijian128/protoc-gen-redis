// Code generated by protoc-gen-redis. DO NOT EDIT.

package cmddb

import (
	"bytes"
	"encoding/gob"
	"fmt"
	"strconv"
	"github.com/gomodule/redigo/redis"
)

// --- Message: User ---

// FieldUser 用于标识 Redis Hash 中的字段编号
type FieldUser uint32

// FieldUser_Id 是字段 Id 对应的 Redis Hash field 编号
const FieldUser_Id FieldUser = 1

// FieldUser_Name 是字段 Name 对应的 Redis Hash field 编号
const FieldUser_Name FieldUser = 2

// FieldUser_Age 是字段 Age 对应的 Redis Hash field 编号
const FieldUser_Age FieldUser = 3

// FieldUserIDs 是所有字段编号常量的集合，类型为 []FieldUser
var FieldUserIDs = []FieldUser{
	FieldUser_Id,
	FieldUser_Name,
	FieldUser_Age,
}

// User 提供针对 User 消息的 Redis 存取操作
type User struct {
	Id uint64

	Name string

	Age uint32
}

// NewUser 创建一个新的 User 实例
func NewUser() *User {
	return &User{}
}

// SetFields 将当前结构体实例的字段值，存储到 Redis Hash 中
// conn: Redis 连接
// REDBKey: 业务维度 Key
// ida, idb: 用于组成唯一 Hash Key 的两个 uint64 分片维度
// fields: 要存储的字段编号列表，如 FieldUser_Name, FieldUser_Age
//
//	如果 fields 为空（长度为 0），则默认存储所有字段（即 FieldUserIDs）
func (p *User) SetFields(conn redis.Conn, REDBKey uint32, ida, idb uint64, fields ...FieldUser) error {
	key := fmt.Sprintf("REDB#%d:%d:%d", REDBKey, ida, idb)
	args := []interface{}{key}

	// 决定要操作的字段列表
	fieldsToUse := fields
	if len(fieldsToUse) == 0 {
		fieldsToUse = FieldUserIDs
	}

	for _, fieldID := range fieldsToUse {
		fieldFound := false

		if fieldID == FieldUser_Id {
			fieldFound = true

			// --- 直存字段: Id ---
			args = append(args, fieldID, p.Id)

		}

		if fieldID == FieldUser_Name {
			fieldFound = true

			// --- 直存字段: Name ---
			args = append(args, fieldID, p.Name)

		}

		if fieldID == FieldUser_Age {
			fieldFound = true

			// --- 直存字段: Age ---
			args = append(args, fieldID, p.Age)

		}

		if !fieldFound {
			return fmt.Errorf("未知字段编号: %d", fieldID)
		}
	}

	_, err := conn.Do("HSET", args...)
	return err
}

// --- Message: User2 ---

// FieldUser2 用于标识 Redis Hash 中的字段编号
type FieldUser2 uint32

// FieldUser2_Id2 是字段 Id2 对应的 Redis Hash field 编号
const FieldUser2_Id2 FieldUser2 = 1

// FieldUser2_Name2 是字段 Name2 对应的 Redis Hash field 编号
const FieldUser2_Name2 FieldUser2 = 2

// FieldUser2_Age2 是字段 Age2 对应的 Redis Hash field 编号
const FieldUser2_Age2 FieldUser2 = 3

// FieldUser2_I32 是字段 I32 对应的 Redis Hash field 编号
const FieldUser2_I32 FieldUser2 = 4

// FieldUser2_I64 是字段 I64 对应的 Redis Hash field 编号
const FieldUser2_I64 FieldUser2 = 5

// FieldUser2_List 是字段 List 对应的 Redis Hash field 编号
const FieldUser2_List FieldUser2 = 6

// FieldUser2_U 是字段 U 对应的 Redis Hash field 编号
const FieldUser2_U FieldUser2 = 7

// FieldUser2_Mp 是字段 Mp 对应的 Redis Hash field 编号
const FieldUser2_Mp FieldUser2 = 8

// FieldUser2IDs 是所有字段编号常量的集合，类型为 []FieldUser2
var FieldUser2IDs = []FieldUser2{
	FieldUser2_Id2,
	FieldUser2_Name2,
	FieldUser2_Age2,
	FieldUser2_I32,
	FieldUser2_I64,
	FieldUser2_List,
	FieldUser2_U,
	FieldUser2_Mp,
}

// User2 提供针对 User2 消息的 Redis 存取操作
type User2 struct {
	Id2 uint64

	Name2 string

	Age2 uint32

	I32 int32

	I64 int64

	List []int32

	U User

	Mp map[uint32]int32
}

// NewUser2 创建一个新的 User2 实例
func NewUser2() *User2 {
	return &User2{}
}

// SetFields 将当前结构体实例的字段值，存储到 Redis Hash 中
// conn: Redis 连接
// REDBKey: 业务维度 Key
// ida, idb: 用于组成唯一 Hash Key 的两个 uint64 分片维度
// fields: 要存储的字段编号列表，如 FieldUser2_Name, FieldUser2_Age
//
//	如果 fields 为空（长度为 0），则默认存储所有字段（即 FieldUser2IDs）
func (p *User2) SetFields(conn redis.Conn, REDBKey uint32, ida, idb uint64, fields ...FieldUser2) error {
	key := fmt.Sprintf("REDB#%d:%d:%d", REDBKey, ida, idb)
	args := []interface{}{key}

	// 决定要操作的字段列表
	fieldsToUse := fields
	if len(fieldsToUse) == 0 {
		fieldsToUse = FieldUser2IDs
	}

	for _, fieldID := range fieldsToUse {
		fieldFound := false

		if fieldID == FieldUser2_Id2 {
			fieldFound = true

			// --- 直存字段: Id2 ---
			args = append(args, fieldID, p.Id2)

		}

		if fieldID == FieldUser2_Name2 {
			fieldFound = true

			// --- 直存字段: Name2 ---
			args = append(args, fieldID, p.Name2)

		}

		if fieldID == FieldUser2_Age2 {
			fieldFound = true

			// --- 直存字段: Age2 ---
			args = append(args, fieldID, p.Age2)

		}

		if fieldID == FieldUser2_I32 {
			fieldFound = true

			// --- 直存字段: I32 ---
			args = append(args, fieldID, p.I32)

		}

		if fieldID == FieldUser2_I64 {
			fieldFound = true

			// --- 直存字段: I64 ---
			args = append(args, fieldID, p.I64)

		}

		if fieldID == FieldUser2_List {
			fieldFound = true

			// --- Gob 序列化字段: List ---
			{
				var buf bytes.Buffer
				if err := gob.NewEncoder(&buf).Encode(p.List); err != nil {
					return fmt.Errorf("gob 编码字段 %s 失败: %v", "List", err)
				}
				args = append(args, fieldID, buf.Bytes())
			}

		}

		if fieldID == FieldUser2_U {
			fieldFound = true

			// --- Gob 序列化字段: U ---
			{
				var buf bytes.Buffer
				if err := gob.NewEncoder(&buf).Encode(p.U); err != nil {
					return fmt.Errorf("gob 编码字段 %s 失败: %v", "U", err)
				}
				args = append(args, fieldID, buf.Bytes())
			}

		}

		if fieldID == FieldUser2_Mp {
			fieldFound = true

			// --- Gob 序列化字段: Mp ---
			{
				var buf bytes.Buffer
				if err := gob.NewEncoder(&buf).Encode(p.Mp); err != nil {
					return fmt.Errorf("gob 编码字段 %s 失败: %v", "Mp", err)
				}
				args = append(args, fieldID, buf.Bytes())
			}

		}

		if !fieldFound {
			return fmt.Errorf("未知字段编号: %d", fieldID)
		}
	}

	_, err := conn.Do("HSET", args...)
	return err
}
